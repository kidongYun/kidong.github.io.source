---
layout: post
title:  "Notepad"
date:   2020-11-23 11:38:54 +0900
categories: 
---


# 주제 DTO, Domain, VO 에 대한 글
1. 요청(파라미터)는 DTO의 필요성을 명확히 알겠음. 그러면 반환해줄때의 객체의 형태는 DTO여야 하는가 아니면 VO여야 하는가... 

2. DTO, VO, Domain 객체 구분해서 사용하기를 원함.

DTO가 비지니스 종속적여야 하는 이유.
-> 공통된 기능을 가졌다고 해서 다른 비즈니스를 공통된 DTO 사용했을 경우에 추후 다른 속성을 사용하는 비즈니스가 들어왔을경우
이 DTO를 분리시켜야함. 단순히 DTO를 분리시킨다는 관점에서는 큰 문제는 아니지만. 그 기능이 인터페이스로 규격화 되어있을 경우
DTO가 특정항공사는 다른 이슈가 생기기 때문에 이는 인터페이스화 시킬수 없는 문제가 발생.

DTO와 Domain이 구분되어져야 하는 이유.
-> 해당 객체가 생성되는 근본적인 이유가 다르기 때문이다. DTO가 가져야할 특성이 있는데 그 중 주된것들은.fS
첫번째 validation 체크이다. DTO는 데이터를 주고받을 때 사용하는 목적으로 만들어진 객체이기 때문에. validation 체크가 기본적으로 통상 들어간다.
Domain 객체와 이러한 DTO를 같이 사용하게 되면 validation 체크를 DTO 자체적으로 구현하지 못하고 별도 서비스단 등에서 제어해야하는 문제가 발생한다.

두번째. 마샬링, 파싱 등의 작업을 할때 조건을 걸어야 하기때문. 조건은 결국 비지니스 종속적일 수밖에 없고 이를 domain 객체에 넣어둘수는 없다.
domain은 모두 공통적으로 사용해야하는 객체이기 때문에 어떤 한 특정 비지스에 종속적인 객체를 만드는 것은 좋지 않은 패턴이다.

세번쨰. DTO 를 디자인하는 것과 도메인 객체를 디자인하는 근본적인 목적이 다르다. DTO 는 딱 주고 받아야할 데이터만 최대한 간단하게 주고받고록 
만들어야하지만 도메인 개체는 객체 모델링 관점에서 실세상을 투영되도록 각 도메인 객체들끼리 관계를 맺어주며 구현해야하기 때문에
설계되는 모양이 근본적으로 다를수 밖에 없다.

Map<> 은 언제 사용되어야 할까.
-> Map은 type safe 하지 않기 때문에 일반적으로는 DTO를 생성하고 해당 객체를 Map을 대신 사용하는 것을 추천한다. 그러나 만약 Map을 사용하는 곳의 Scope가
한 함수의 내부적으로만 사용하고 해당 함수를 사용하는 다른 클라이언트들에게 이 Map 객체를 전달할 일이 없다면 해당 타입을 다른 클라이언트가 지속 사용하는
현상이 일어나지 않음으로 구조가 심플하고, 스코프가 한 함수 내부라면 사용하는것이 좋을듯 하다. Java POJO 객체를 계속 만들어 나가는것도 결국에는 양이 엄청나기 때문
이정도로 사이즈가 작고 클라이언트에게 큰 영향이 없다면 그냥 Collection Framework를 사용하는 것도 좋을 것 같다.

3. innerClass 를 활용한 DTO, Domain 구분 무엇이 DTO이고 무엇이 Domain 일까
    - 다른패키지에서 같은 이름으로 만들수는있어도 이를 한 클래스에서 같이 사용할 수는 없다.

Domain.DTO -> 이미 장점을 알고있는 구조.
    각 비지니스에 맞추어서 POJO 객체를 쓸 수 있다.
    Spring Validation 가능 위에서도 이미 언급되고 있음.
    Flat Design

Boundary.DTO, Package.DTO
    -> innerClass 로 구현
    -> 영역의 구분에 대한 장점 패키지로 하는것 보다 더 제한적
    -> 이름이 중복될수 없음.
    -> 특정 비지니스에 종속되어 있는 DTO 임을 명시 가능.

DTO.Domain -> 불가능한 구조 Domain 이라함은 공용으로 사용하는 POJO 객체 인데. 이것이 특정 비지니스에 맞추어져 있는 DTO 안에 들어갈 수 없음.

Domain.DTO.DTO -> 가능은 함 그러나 권장하지 않는 구조, Domain.DTO 에 들어가는 조건 중 하나는 Domain과 관련된 DTO가 들어가야함.

Domain.DTO 구조로 설계했는데 Domain에 마땅히 들어갈 데이터가 없다면 Boundary.DTO 형태로 변경을 고려해야함.

Domain이 될수있는 조건은 프로젝트 모든 곳에서 사용할 수 있는 구조인가를 고려해야함. 그리고 그런 데이터인지. 그렇기때문에 일반적으로 데이터베이스 엔티티 구조를 따른다

DAO는 결국 DB와 DOMAIN을 연결하는 DTO의 일종이다. 보통 DTO는 뷰와 DOMAIN을 연결하는 요소로 언급함. 내가볼때는 둘다 DTO로 봐도되지 않나.. 용어의 정의를 내가 내리지 않았으니
이 둘을 구분은 해야할듯 DTO는 View - Domain, DAO는 Domain - DB

jpa를 활용하지 않고 최대한 의존성이 적은 쿼리를 짜는 방법 -> 결국 동적쿼리를 써야함으로 DB 캐싱은 사용할 수 없다 성능은 떨어짐 이슈. 그리고 쿼리가 최대한 의존적이지 않ㄱ ㅔ짜기 때문에
대부분 분리된 방식으로 짬 -> 트랜잭션 관리 가 더커짐.

테이블이 3개를 기준으로 쿼리를 가져와야 한다면. 해당 테이블 기준으로 Domain 객체 3개를 우선 만들고 이들을 합쳐 DAO를 만든다 그래서 파라미터로 들어가야할 부분에는 이 값들을 넣어준다.
쿼리는 가능한 한도 내에서 동적쿼리로 작성

내가아까 푸쉬를 했나??



3. set하는 코드보다 builder 하는 코드가 좋은이유 가독성 측면에서

10000줄짜리 한 스코프의 코드가 있다고 하자. 이거 자체가 굉장히 억지스러운 일이지만.
만약 1번째 줄에 선언된 변수가 10000째에서 사용된다고 하면. 그 사이의 작업이 어떤것이 있었는지 다 확인해야한다.
그런데 만약 10000번째에 반환시키는 변수를 빌더로 사용한다면. 거기안에 들어가있는 변수들만 쫓아가면 된다
변수를 좀더 사용하기 때문에 공간복잡도는 조금더 올라가겠지만. 가독성은 향상된다.
그러나 변수명을 모두 지정해줘야하는 문제가 있다.

# 주제 . 인터페이스 설계의 이점

# 주제. null 체크 (with optional)

한 함수 스코프로 잡고 그 안에서의 null 처리를 하라.
무의미한 null 처리라면 로깅의 목적으로로 쓸수 있다.
객체에서 객체를 계속 참조하는 구조가 nullpointerexception의 취약점이다.
set 할때보다 get 할때를 유의하라.

# 주제. 리플렉션 기본 문법.
    - 필드 가져오기
    - 메소드 가져오기
    - private 접근하기
    - getter/setter 접근하기
    


# 주제. 리플렉션 과 스프링 생성자로 만들어진 객체는 바로 빈주입이 되지 않는다

6. 생성자주입 사용시 NoArgs 생성자 사용을 어떻게 하는가 with reflection
생성자 주입을 사용하면 해당 객체를 생성할때 해당 의존성을 반드시 전달해야하는 문제.
리플렉션, new 로 객체생성시 빈등록이 안되는 문제에대해서

해결방법

1. 스프링 빈 컨테이너를 가지고있는 ApplicationContext 객체를 Static 메모리에 올리고 접근할 수 있도록 함.
2. 리플렉션시 생성자에 ApplicationContext 객체를 파라미터로 주입받고 이 객체를 통해 내부적으로 빈 주입을 진행.


# 주제. FLUX

### Flux pattern

View Framework 쪽에서 상태관리를 할때 현대에는 대부분 Flux 패턴을 활용한다. 해당 패턴에 대해서 좀더 분석해야할 필요성이 있다.
action -> dispatcher -> reducer -> view...

### Redux
사용방법

### Redux 비동기 통신

### Redux 로깅

### Redux Thunk

### typesafe-actions

### Mobx
사용방법

# 주제. HttpClient 를 활용한 HTTP 통신 방법

### URI 생성

### 쿠키 생성

### Header 주입

### GET, POST

```java

    public static String get(String url) throws URISyntaxException, IOException {
        URI uri = new URI("http://batchadmin.interparktour.com/admin/airControlTimerGet.do?searchAirline=AL");
        uri = new URIBuilder(uri).addParameter("searchAirline", "AL").build();

        HttpClient httpClient = HttpClientBuilder.create().build();

        HttpGet httpGet = new HttpGet(uri);
        httpGet.setHeader("Content-Type", "application/json");
        HttpResponse response = httpClient.execute(httpGet);
        HttpEntity entity = response.getEntity();
        return EntityUtils.toString(entity);
    }
```

```java

    public static String get(String url) throws URISyntaxException, IOException {
        URI uri = new URI(url);
        uri = new URIBuilder(uri).addParameter("searchAirline", "AL").build();

        /** 쿠키 처리 */
        BasicCookieStore cookieStore = new BasicCookieStore();
        BasicClientCookie cookie = new BasicClientCookie("ADMIN_ID", "N19147");
        cookie.setDomain("batchadmin.interparktour.com");
        cookie.setPath("/");
        cookieStore.addCookie(cookie);

        BasicClientCookie cookie2 = new BasicClientCookie("AWP_KEY", Utility.getEncSHA256("interpark_N19147_airadmin12#$"));
        cookie2.setDomain("batchadmin.interparktour.com");
        cookie2.setPath("/");
        cookieStore.addCookie(cookie2);

        HttpClient httpClient = HttpClientBuilder.create().setDefaultCookieStore(cookieStore).build();

        /** Get 혹은 Post */
        HttpGet httpGet = new HttpGet(uri);
        httpGet.setHeader("Content-Type", "application/json");
        HttpResponse response = httpClient.execute(httpGet);
        HttpEntity entity = response.getEntity();

        return EntityUtils.toString(entity);
    }
```

# 주제. Stub을 활용한 테스트 코드 작성법

### 소스 분리
1. 외부 리소스를 활용하는 소스 분리

### 추상체 구현
2. 외부 리소스를 포함한 코드를 테스트하고 싶을떄에는 외부 리소스를 가져오는 객체의 추상체를
새롭게 구현하는 Stub 객체를 만들어서 테스트.
추상체가 없다면 이 방법은 사용 불가능.
추상체를 만들고, Stub 객체를 만들어야 하기때문에 1번방법보다는 보일러플레이트 코드가 많아짐
하지만 외부리소스를 포함한 코드도 테스트를 할수 있는 방법이 됨으로 테스트 커버리지가 높아짐.

내가볼때는 1, 2번 방법 모두를 사용하는 코드를 짜는게 좋은 코드일듯.

외부에서 주입을 할수 있도록 생성자 주입, Setter 주입 형태로 만들어 줘야함.

```java

	public PnrStatus.Res pnrStatus(PnrStatus.Req req) throws Exception {
		return this.pnrStatus(req, AirlineFactory.create(req.getAirline()));
	}

	private PnrStatus.Res pnrStatus(PnrStatus.Req req, Airline airline) throws Exception {
		if(req == null || StringUtils.isEmpty(req.getAirline())) {
			throw new Exception("파라미터 'req' 에서 항공사 코드를 가져올 수 없습니다");
		}

		return airline.pnrStatus(req);
	}

```

Stub 적용을 위한 외부소스 분리에는 리플렉션도 적용될 수 있을 것 같다.
위처럼 짜면 Airline 객체를 함수 외부 영역이기때문에 pnrStatus


### Mock, InjectMock 사용
파라미터도 같아야 합니다. -> 파라미터가 객체라면 이 객체도 Mock으로 잡아줘야한다. 객체끼리가 참조하는 곳이 다르면 다른 객체로 인식.
Mock끼리 의존성이 있는경우 의존된 객체의 함수들도 when().then() 으로 가짜 값을 반환하도록 만들어 줘야한다.
Mocking을 하려면 객체의 필드레벨로 해당 참조객체를 빼와야 하는데 Mocking할 대상이 만약 stateful한 객체라면 쓰레드 세이프하지 않을텐데.. 이럴뗀 어떻게??
이건 추후에 찾아봐야할듯.

컨트롤러 통합테스트할때는 서비스도 Mocking 해야함

final로 선언하면 Mock이 의존성 주입을 못하네.. 어떻게 해야하지.. -> 이거 꽤 심각한 이슈인데.. 우선은 컨트롤러쪽 테스트할때만 final 빼고 테스트하게끔 구성해야할듯

junit5, TestNG 등등 찾아봐야할듯 함

stub 이 필요한 객체를 테스트 커버리지의 영역 밖으로 뺄수 있으면 간단하게 테스트할수 있고 그 구조가 제일 좋은거같음
그런데 그렇지 못할 경우 @Mock, @InjectMock 을 활용해서 stub 함수를 주입해서 테스트.

MockMvcBuilders.standalone()... 요거 활용해서 컨트롤러에 목객체를 주입할 수 있다

한계점은 객체를 항상 클래스 레벨에서 노출을 시켜야 Mocking이 가능하다는 점. -> 리플렉션 되는 객체는 애초에 불가능

샘플

```java

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.Mockito.when;

    @Mock
    private AirfarePrice airfarePrice;
    @Mock
    private AirDemandTicket airDemandTicket;
    @InjectMocks
    private AirseoulTicketingService airseoulTicketingService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

        /** 'TKT634 OFFICE DATABASE MAXIMUM *DATE OVERFLOW*CONTACT SI' 오류 응답을 받을 때 적절히 파싱되는지 확인 */
    @Test
    public void ticketing_DbMaxoverflowErrorIsOccured() throws Exception {
        String airApiRequestInfoStub = "<AirApiRequestInfo Version=\"1.1\"><Config format=\"airseoul\" validationModule=\"VALIDATION_DOM_RS\" service=\"ticketing\"/><Response format=\"xml\" type=\"pc\"/><QueryString><![CDATA[authorizationCode=08086203&SEGIN=RS/905/202103261450/GMP/CJU/202103261600/Y/KRW/0/YHOW&idCode=ADT]]></QueryString><PnrService pnrAddr=\"HJ070\" pnrKey=\"500021127\"><AirlineCode>RS</AirlineCode></PnrService><PassengerService><PassengerList><PassengerData passengerType=\"ADT\" passengerKey=\"1\"><GivenName>기동</GivenName><Surname>윤</Surname><PTC>ADT</PTC></PassengerData></PassengerList></PassengerService><PaymentService><PaymentList><PaymentData type=\"CC\"><Amount>110000</Amount><CardCode><![CDATA[u3HUpnRURJ2uGkWnJ6lUkg==]]></CardCode><CardNumber><![CDATA[LjtbuPEUtStUn9nPD1ARfg==]]></CardNumber><Expiration><![CDATA[aXzFsA2YhFwQlQh/3LlCrA==]]></Expiration><Installment>00</Installment></PaymentData></PaymentList></PaymentService></AirApiRequestInfo>";
        AirApiRequestInfo param = (AirApiRequestInfo) jaxbMarshaller.unMarshall(AirApiRequestInfo.class, airApiRequestInfoStub);

        String airDemandTicketRSStub = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Conversation xmlns=\"http://sita.aero/hal\" id=\"conv-16p-1605634071703-147\" server=\"10.213.26.166\" timestamp=\"2020-11-17 17:27:51\"/></Header><SOAP-ENV:Body><SITA_AirDemandTicketRS xmlns=\"http://sita.aero/SITA_AirDemandTicketRS/4/0\" xmlns:common=\"http://sita.aero/common/2/0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" Version=\"0\"><Errors><common:Error Code=\"101\" Tag=\"FETA\" Type=\"Host Error Response\">TKT634 OFFICE DATABASE MAXIMUM *DATE OVERFLOW*CONTACT SI</common:Error></Errors></SITA_AirDemandTicketRS></SOAP-ENV:Body></SOAP-ENV:Envelope>";
        airDemandTicketRSStub = airseoulCommonInfo.getBodyString(airDemandTicketRSStub)
                .replace(" xmlns=\"http://sita.aero/SITA_AirDemandTicketRS/4/0\"", "")
                .replace(" xmlns:common=\"http://sita.aero/common/2/0\"", "")
                .replace(" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"", "")
                .replaceAll("common:", "");
        SITA_AirDemandTicketRS airDemandTicketRS = (SITA_AirDemandTicketRS) jaxbMarshaller.unMarshall(SITA_AirDemandTicketRS.class, airDemandTicketRSStub);

        when(airfarePrice.getAirFarePriceRS(param)).thenReturn(new SITAAirfarePriceRS());
        SITAAirfarePriceRS airPriceRS = airfarePrice.getAirFarePriceRS(param);

        when(airDemandTicket.getAirDemandTicketRS(param, airPriceRS)).thenReturn(airDemandTicketRS);

        PaymentResult result = airseoulTicketingService.ticketing(param);

        log.info(jaxbMarshaller.marshall(result));
        assertThat(result.getErrorNo(), is("101"));
        assertThat(result.getErrorDesc(), is("TKT634 OFFICE DATABASE MAXIMUM *DATE OVERFLOW*CONTACT SI"));
    }

```

### Mock 에서 Real 객체 사용

```java

    @Mock(answer = Answers.CALLS_REAL_METHODS)
    MypageMapper mypageMapper;

```


### WireMock (Stub Server)
외부 서버도 일종의 가짜 서버를 두고싶을떄 사용할 수 있따.
위의 Stub을 만드는 방법은 결국 소스레벨에서 테스트하는 방법이기 떄문에. 스테이징 수준으로 테스트 레벨이 올라가게 되면
기획자나 다른 비개발자 직군은 테스트가 불가능하다. 
이럴떄는 가짜 데이터를 고정되게끔 줄수있는 스텁서버를 하나 구축을 해두면 테스트가 원활해질수 있다

### Static 클래스 Mocking


Stub 쓰는법 첫번째 -> 외부 자원들은 (리플렉션, API call, 특정 변수들, DB) 함수의 입력으로 가져오게끔 하라.
-> 의존성을 줄이는 방법중 첫번째이다.

Stub 쓰는법 두번째 -> 의존성을 제거할 수 없다면 Mocking을 하라




# 주제. async, await, promise, then


# 주제 React에서 Component 와 Data
Component 설계할때 데이터에 영향이 있는것은 주입받도록 만들고 나머지는 해당 컨테이너에서 처리하면된다.
추상화 기법은 Component 작업할때 별로 좋지 않은것 같다.
styled 와 관련된 Component 를 두고 예를 추상화 시켜서 쓰려고 했는데. 결국 css 문법을 계속 한번씩 확인하게 되고.

width, height 등과 관련된 Layout Component 하나 두고 이걸로 저런 값들을 조절하고

button, label 등의 글자나 특색이있는 UI 요소들은 다른 component로 둬서 둘을 결합해서 사용하는게 좋은듯.

이런식으로 기본적으로 내가 만든 모든 컴포넌트는 레이아웃에 특별함이 필요하다하면 저걸로 감싸는거지.
<LayoutComponent>
    <ButtonComponent>
</LayoutComponent>

레이아웃적인 요소와 특정 컴포넌트만 가지는 요소를 구분시키고 이 레이아웃적인 요소를 감싸게끔 만드는게 진짜 조은듯

Data는 State를 기준으로 Store, Action, Reducer를 설계한다. State를 표현하기 위한 Store, State를 조작하기 위한 Action 들 인것이다.


### 주제. 제네릭 메서드 빌더

```java

package com.awb.domair.adminAwp.vo;

public class Response<T> {
    private int status;
    private T body;

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public T getBody() {
        return body;
    }

    public void setBody(T body) {
        this.body = body;
    }

    @Override
    public String toString() {
        return "Response{" +
                "status=" + status +
                ", body=" + body +
                '}';
    }

    public static class Builder<T> {
        private final Response<T> response;

        public Builder() {
            this.response = new Response<>();
        }

        public Builder<T> status(int val) {
            this.response.status = val;
            return this;
        }

        public Builder<T> body(T val) {
            this.response.body = val;
            return this;
        }

        public Response<T> build() {
            return response;
        }
    }
}

```


### String.valueOf() null일때 -> 'null' 이 되어버림


### JPA 에 대한 글

1. 기본적인 JPA 설정.

2. JPA + QueryDSL



### O.O.P 와 F.P 문제 해결 접근 방법 비교


### DBResultSet <-> Map, T

```java

import com.fasterxml.jackson.databind.ObjectMapper;
import java.sql.SQLException;
import java.util.*;

public class ResultSetUtil {

    /** DBResultSet -> List<Map<String, Object>> */
    public static List<Map<String, Object>> toMap(DBResultSet rset) throws SQLException {
        List<Map<String, Object>> rows = new ArrayList<>();
        rset.initRow();

        while (rset.next()) {
            Map<String, Object> column = new HashMap<>();
            for(int i$ = 1; i$ <= rset.columnCount; i$++) {
                column.put(rset.getColumnName(i$), rset.getObject(i$));
            }
            rows.add(column);
        }

        return rows;
    }

    /** List<Map<String, String>> -> List<T> */
    public static <T> List<T> toDomain(List<Map<String, Object>> maps, Class<T> clazz) {
        List<T> objects = new ArrayList<>();
        for(Map<String, Object> map : maps) {
            objects.add(new ObjectMapper().convertValue(map, clazz));
        }

        return objects;
    }

    /** DBResultSet -> List<T> */
    public static <T> List<T> toDomain(DBResultSet rset, Class<T> clazz) throws SQLException {
        return toDomain(toMap(rset), clazz);
    }

    /** List<Map<String, String>> -> DBResultSet */
    public static DBResultSet toResultSet(List<Map<String, Object>> rows) throws SQLException {
        Set<String> columnNames = rows.get(0).keySet();
        EditableResultSet ers = new EditableResultSet(columnNames.toArray(new String[0]));

        for(Map<String, Object> row : rows) {
            ers.absolute(ers.addRow());
            for(String columnName : columnNames) {
                ers.setValue(columnName, row.get(columnName));
            }
        }

        return ers;
    }

    /** List<T> -> DBResultSet */
    public static <T> DBResultSet parseResultSet(List<T> rows) throws SQLException {
        return toResultSet(toMap(rows));
    }

    /** List<T> -> List<Map<String, String>> */
    @SuppressWarnings("unchecked")
    public static <T> List<Map<String, Object>> toMap(List<T> rows) {
        List<Map<String, Object>> maps = new ArrayList<>();

        for(T row : rows) {
            maps.add(new ObjectMapper().convertValue(row, Map.class));
        }

        return maps;
    }
}


```


### 주제

```java

public static <T extends AirLine> AirLine create(String airline) throws Exception {
    Class<T> clazz = (Class<T>) Class.forName("com.air.interpark.ariLine.AirLine" + airline);

    Class[] classArgs = {};
    Constructor<T> constructor = clazz.getDeclaredConstructor(classArgs);

    return constructor.newInstance();
}

public static AirLine createRaw(String airline) throws Exception {
    Class clazz = Class.forName("com.air.interpark.ariLine.AirLine" + airline);

    Class[] classArgs = {};
    Constructor constructor = clazz.getDeclaredConstructor(classArgs);

    return (AirLine) constructor.newInstance();
}

```


# 주제 Spring AOP

Spring boot 안쓰고 Spring 으로 할경우 Dependencies 추가해줘야함.

```
	compile group: 'org.aspectj', name: 'aspectjrt', version: '1.9.2'
	compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.9.2'
```

아래와 같이 Aspect 소스를 짰음

```java

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@Aspect
public class AirlineLog {
    @Around("within(com.air.interpark.ariLine.common.*)")
    public Object loggerAop(ProceedingJoinPoint joinPoint) throws Throwable {
        log.info("It's loggerAop");
        return joinPoint.proceed();
    }
}

```

어드바이스 종류는 대따 많음

Around 어드바이스

타겟의 메서드가 호출되기 이전(before) 시점과 이후 (after) 시점에 모두 처리해야 할 필요가 잇는

부가기능을 정의한다.

-> Joinpoint 앞과 뒤에서 실행되는 Advice



Before 어드바이스

타겟의 메서드가 실행되기 이전(before) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다.

-> Jointpoint 앞에서 실행되는 Advice



After Returning 어드바이스

타겟의 메서드가 정상적으로 실행된 이후(after) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다.

-> Jointpoint 메서드 호출이 정상적으로 종료된 뒤에 실행되는 Advice



After Throwing 어드바이스

타겟의 메서드가 예외를 발생된 이후(after) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다.

-> 예외가 던져 질때 실행되는 Advice


조인포인트를 어노테이션으로도 줄수 있음

@EnableAspectJAutoProxy
-> 

ProxyTargetClass
->

joinPoint.getArgs() 이걸로 타켓 메소드에 들어가는 parameter 정보를 가져올 수 있다.

pointjoint 할때 쓰는 expression 들도 알아야 할듯

리플렉션하는 소스를 스테이틱이 아닌 스프링 빈을 활용한 싱글톤 형태로 구현하면.
리플렉션시 빈을 주입받지 못하는 오류를 해결할 수 있다.


## 주제. AOP

1. 기본적인 로깅

2. 중복되는 로깅 소스 발견 -> 새로운 로깅 객체 생성 하여 콜

3. 비지니스 로직에 새로운 로깅 객체를 계속 콜하는 소스가 발견 -> 메인 비지니스 소스에는 로깅 같은 소스를 안넣었으면 좋겟음. -> proxy 패턴 사용

4. 인터페이스를 활용한 proxy 패턴 확장

5. Spring AOP 활용.

6. Annotation 활용한 AOP

7. Spring AOP + custom annotation + SpEL



## 주제. Annotation

```java

package reflection;

import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * 어노테이션 정의
 */
@Retention(RUNTIME)
public @interface Check {
    String value();
}
```

```java

package reflection;

/**
 * 조작 대상 클래스
 */
@Check("클래스에 부여")
public class AnnotationSample {

    @Check("메소드에 부여")
    public void print(@Check("인수에 부여") String message) {
        System.out.println(message);
    }
}

```

```java

package reflection;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;

public class AnnotationMainSample {

  public static void main(String[] args) throws NoSuchMethodException {

    Class<AnnotationSample> clazz = AnnotationSample.class;

    /////////////////////////////////////////////////////////////////////////////
    // 클래스에 부여한 @Check를 얻기
    /////////////////////////////////////////////////////////////////////////////
    {
        Check check = clazz.getAnnotation(Check.class);
        System.out.println(check);
        System.out.println(check.value());
    }

    /////////////////////////////////////////////////////////////////////////////
    // 메소드에 부여한 @Check를 얻기
    /////////////////////////////////////////////////////////////////////////////
    Method method = clazz.getMethod("print",  String.class);
    
    // @Check가 부여되어 있는 경우
    if (method.isAnnotationPresent(Check.class)) {
        Check check = method.getAnnotation(Check.class);
        System.out.println(check);
        System.out.println(check.value());
    } 

    /////////////////////////////////////////////////////////////////////////////
    // 인수에 부여한 @Check를 얻기
    /////////////////////////////////////////////////////////////////////////////
    for (Annotation[] params : method.getParameterAnnotations()) {
        for (Annotation annotation : params) {
            Check check = (Check) annotation;
            System.out.println(check);
            System.out.println(check.value());
        }
    }
  }
}

```

```java

import java.lang.annotation.*;

@Inherited
@Documented
@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능합니다.
//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효합니다.
//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 없어집니다.
@Target({
        ElementType.PACKAGE, // 패키지 선언시
        ElementType.TYPE, // 타입 선언시
        ElementType.CONSTRUCTOR, // 생성자 선언시
        ElementType.FIELD, // 멤버 변수 선언시
        ElementType.METHOD, // 메소드 선언시
        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시
        ElementType.LOCAL_VARIABLE, // 지역 변수 선언시
        ElementType.PARAMETER, // 매개 변수 선언시
        ElementType.TYPE_PARAMETER, // 매개 변수 타입 선언시
        ElementType.TYPE_USE // 타입 사용시
})
public @interface MyAnnotation {
    /* enum 타입을 선언할 수 있습니다. */
    public enum Quality {BAD, GOOD, VERYGOOD}
    /* String은 기본 자료형은 아니지만 사용 가능합니다. */
    String value();
    /* 배열 형태로도 사용할 수 있습니다. */
    int[] values();
    /* enum 형태를 사용하는 방법입니다. */
    Quality quality() default Quality.GOOD;
}

```

위와같이 다양한 형태의 값을 넣을 수 있음


```java

@Around(value = "@annotation(domActionLog)")
    public Object domActionLogging(ProceedingJoinPoint joinPoint, DomActionLog domActionLog) throws Throwable {
        log.info(domActionLog.toString());

        log.info("REQ : " + Arrays.toString(joinPoint.getArgs()));

        Class<AirlineRS> clazz = AirlineRS.class;

        Method method = clazz.getMethod("pnrStatus", PnrStatus.Req.class);
        if(method.isAnnotationPresent(DomActionLog.class)) {
            DomActionLog annotation = method.getAnnotation(DomActionLog.class);
            System.out.println(annotation);
            System.out.println(annotation.prId());
            System.out.println(annotation.pnr1());
        }

        Object obj = null;
        try {
            obj = joinPoint.proceed();
            log.info("RES : " + obj.toString());
        } catch (Exception e) {
            log.info("RES : " + e.toString());
        }

        return obj;
    }

```

DomActionLog 부분을 Around annotation 이름과 맞추면 파라미터로 받을 수 있다.




내가 만들어둔 소스

dependencies

```
	compile group: 'org.aspectj', name: 'aspectjrt', version: '1.9.2'
	compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.9.2'
```

config (It should be turned on @EnableAspectJAutoProxy with proxyTargetClass = true option)

```java

@Configuration
@EnableWebMvc // <annotation-driven />
@EnableAspectJAutoProxy(proxyTargetClass = true)
@ComponentScan(basePackages = { "com.air.*" })
@Slf4j
public class WebConfig extends WebMvcConfigurerAdapter{
    ...
}

```

annotation

```java

import java.lang.annotation.*;

@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DomActionLog {
    String prId();
    String pnr1();
    String param() default "";
}


```

Aspect Source

```java

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;



@Slf4j
@Aspect
@Component
public class CommonAspect {

    @Around(value = "@annotation(DomActionLog)")
    public Object domActionLogging(ProceedingJoinPoint joinPoint) throws Throwable {
        
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        DomActionLog annotation = method.getAnnotation(DomActionLog.class);

        Object pnr1 = getDynamicValue(signature.getParameterNames(), joinPoint.getArgs(), annotation.pnr1());
        Object prId = getDynamicValue(signature.getParameterNames(), joinPoint.getArgs(), annotation.prId());

        Object result = joinPoint.proceed();

        return result;
    }

    public static Object getDynamicValue(String[] parameterNames, Object[] args, String key) {
        ExpressionParser parser = new SpelExpressionParser();
        StandardEvaluationContext context = new StandardEvaluationContext();

        for(int i$=0; i$< parameterNames.length; i$++) {
            context.setVariable(parameterNames[i$], args[i$]);
        }

        return parser.parseExpression(key).getValue(context, Object.class);
    }
}


```

target source

```java

    @Override
    @DomActionLog(prId = "#req.prId", pnr1 = "#req.pnr1")
    public PnrStatus.Res pnrStatus(PnrStatus.Req req) throws Exception {
        /* 필수 파라미터 확인 */
        if(req == null || StringUtils.isEmpty(req.getPnr1())) {
            throw new Exception("파라미터 'pnr1' 정보가 null 이거나 공백입니다");
        }

        /* 리트리브 */
        RetrieveDetail retrieveDetail = (RetrieveDetail) jaxb.unMarshall(RetrieveDetail.class,
                airLineGateway.call(
                        AirLineGateway.ServiceUrl.RETRIEVE.name(),
                        airLineRQBuilder.retrieveRQBuilder(new PassengerRecordVO(req.getPnr1(), "-1", req.getAirline()), ""),
                        req.getAirline()
                )
        );

        /* 취소 리트리브 */
        List<RetrieveResult> retrieveResults = new ArrayList<>();
        for(String ticketNo : this.ticketNos(retrieveDetail)) {
            retrieveResults.add((RetrieveResult) jaxb.unMarshall(RetrieveResult.class,
                    airLineGateway.call(
                            AirLineGateway.ServiceUrl.TICKET_RETRIEVE.name(),
                            airLineRQBuilder.ticketDetailRetrieve(req.getPnr1(), "", req.getAirline(), Collections.singletonList(ticketNo)),
                            req.getAirline()
                    )
            ));
        }

        return this.pnrStatus(retrieveResults);
    }

```

Test code 

```java

    @Test
    public void run() throws Exception {
        PnrStatus.Res res = airlineRS.pnrStatus(new PnrStatus.Req.Builder().airline("RS").prId("50001234").pnr1("JR85F").build());
    }

```


### 예외처리

3가지 형태의 케이스가 존재한다.

1. 정상적인 경우
-> 소스를 짤때 일반적으로 이 부분에 몰두를 하고 작업을 한다.

2. 처리가 가능한 예외가 발생한 경우
-> 보완로직을 수행하도록 분기한다.

3. 처리가 불가능한 예외가 발생한 경우
-> 상세 에러 메시지를 포함하여 Exception을 던진다.

null 체크할때 마지막애는 필수로 안해도된다

### 주제. Git 충돌

1. reset 시킬때

git reset --head [commit 번호]
git push origin +master

2. 머지 충돌 A + B = AB

3. 머지 충돌 A + B = C