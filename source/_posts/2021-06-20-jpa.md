---
layout: post
title:  "Jpa"
date:   2021-06-20 00:0054 +0900
categories: java
---

# 고급 매핑

## 상속 관계 매핑

### Joined Strategy (조인 전략)

엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략이다. 객체는 타입으로 서브타입들을 구분할 수 있지만 테이블에는 타입의 개념이 없다. 그렇기 때문에 JPA는 DTYPE 컬럼을 자동으로 추가하여 구분 필드로 사용한다.

```java

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {
    private String artist;
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
    private String director;
    private String actor;
}

```

- @Inheritance(strategy = InheritanceType.JOINED) : 상속관계를 설정하려면 @Inheritance 어노테이션을 부모 클래스에 적용해야 한다. 그리고 strategy 속성에 매핑 전략을 설정해주어야 하는데 여기에서는 조인 전략을 넣었다.

- @DiscriminatorColumn(name = "DTYPE") : 부모 클래스에 구분 컬럼을 지정할 때 사용하는 어노테이션. DTYPE 은 기본값이기 떄문에 name 속성을 생략해도 되며, 하이버네이트를 포함한 일부 구현체는 어노테이션 자체를 생략해도 된다.

- @DiscriminatorValue("M") : 엔티티를 저장할 때 구분 컬럼에 입력할 값을 저장한다. 그렇기 때문에 이 어노테이션은 서브타입에 붙는다.

- @PrimaryKeyJoinColumn : 부모 테이블의 PK 컬럼 명을 자식 테이블에서 변경하여 사용하고 싶을 때 이 어노테이션을 사용하면 된다.

장점
-   테이블이 정규화된다.
-   외래 키 참조 무결성 제약조건을 활용할 수 있다.
-   저장공간을 효율적으로 사용한다.

단점
-   조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다.
-   조회 쿼리가 복잡하다.
-   데이터를 등록할 INSERT SQL을 두 번 실행한다.

### Single-Table Strategy (단일 테이블 전략)

테이블을 하나만 사용해서 상속 관계를 표현한다. 그리고 DTYPE 컬럼으로 어떤 자식 데이터가 저장되었는지를 구분한다. 조회할 때 조인을 하지 않기 때문에 일반적으로 가장 빠르다. 이 전략을 사용할 때 주의할 점은 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다는 점이다.

```java

@Entity
@Inheritance(strategy = InheritanceType.SINGEL_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item { ... }

@Entity
@DiscriminatorValue("M")
public class Movie extends Item { ... }

@Entity
public class Book extends Item { ... }

```

장점
-   조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
-   조회 쿼리가 단순하다.

단점
-   자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.
-   단일 테이블에 모든 것을 저장하기 때문에 테이블이 커진다. 그렇기 때문에 상황에 따라서는 조회 성능이 오히려 느려질 수 있다. (데이터 양이 많은 테이블로 예상된다면 SINGLE_TABLE 전략보다는 JOINED 전략이 빠를 수 있다.)

## @MappedSuperclass

부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공받고 싶으면 @MappedSuperclass를 사용하면 된다. 이 어노테이션은 단순히 매핑 정보를 상속할 목적으로만 사용된다.

```java

@MappedSuerclass
public abstract class BaseEntity {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
}

@Entity
public class Member extends BaseEntity {
    private String email;
}

@Entity
public class Seller extends BaseEntity {
    private String shopName;
}

```

BaseEntity에는 객체들이 주로 사용하는 공통 매핑 정보를 정의햇다. 그리고 자식 엔티티들은 상속을 통해 BaseEntity의 매핑 정보를 물려받았다. 여기서 BaseEntity는 테이블과 매핑할 필요가 없고 자식 엔티티에게 공통으로 사용되는 매핑 정보만 제공하면 된다.