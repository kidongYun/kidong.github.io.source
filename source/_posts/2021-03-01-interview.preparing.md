---
layout: post
title:  "Interview Preparing"
date:   2021-03-01 00:0054 +0900
categories: java
---

## 1. Dead Lock (교착상태)

Mutual Exclusion (상호배제)

자원은 한번에 한 프로세스만이 사용할 수 있다.


## 2. Transaction

DBMS는 기본적으로 질의 처리기와 저장 시스템 두 부분으로 나누어진다.

그리고 저장 시스템에 메인 메모리에 유지하는 페이지들을 관리하는 페이지 버퍼라는 모듈이있다.
이 페이지 버퍼라는 모듈이 트랜잭션 과리를 하는데 매우 중요한 결정을 한다.

## 3. IoC (Inversion Of Control)

의존성 주입의 책임을. 개발자에게 넘기는게 아니고. 프레임워크에서 해준다. 제어의 역전이라고 해서 제어의 주체가 개발자가 아닌 프레임워크가 가져갔다는 의미.

의존성 관리라는 것이 커지면 커질수록 꽤나 부담이 되는 요소.

그렇기에 스프링 같은경우 스프링 컨테이너에서 빈들을 등록해두고. 여기서 의존성들을 주입시켜줄수 있또록 한다.

## 4. MVC (Model View Controller)

Model => 데이터를 가공하고 관리하는 영역
Persistant Layer 같은 곳.

View => 타임리프, jsp 같은 뷰 사이드.
여기서 보여지는 데이터들은 이 뷰영역에서 만들어지는 것이 아니고 Controller에서 받는다.

Controller -> 중간에서 Model 과 View 사이에서 매핑해준다.

장점 : MSA 중 하나의 패턴이라고 생각한다. 모듈화가 되기 때문에 어플리케이션의 유연성, 확장성이 증가된다.

## 5. 웹서버

### 멀티쓰레드 방식

#### Prefork MPM
MPM 방식 (Multi Process Module) - prefork
MPM-prework : 멀티 프로세스 방식 마스터 프로세스가 있고 요청이 들어오면 슬레이브 프로세스를 fork 하여 만들고 이 슬레이브 프로세스에서 요청에 대한 처리를 한다.
매 요청에 맞춰서 슬레이브 프로세스를 만들어야 하기때문에 프로세스가 계속 늘어나는 문제점과, 매번 요청에 따라서 슬레이브 프로세스로 바꾸는 context switching 비용이 있다.

#### Worker MPM
MPM-worker : 멀티 쓰레드 방식. 위 방식과 거의 유사하며 프로세스 대신 쓰레드를 사용하는 것이 다르다.


### nginx vs apache (이벤트 루프 vs 멀티쓰레드방식)

apache 웹서버에서 요청을 처리하기 위해 사용하는 쓰레드 기반 모델은 각 클라이언트가 하나의 쓰레드를 물고 처리.
이는 하나의 프로세스가 공통적으로 사용하는 자원이 release 될 때까지 I/O가 blocking 됨.
또한 더 많은 자원을 필요로 함 (Context Switching 비용이 큼)

아파치 웹 서버는 구조적으로 멀티 스레드/멀티 프로세스 기반으로 동작. 클라이언트의 요청이 들어오면 스레드를 생성하거나 혹은 이미 만들어져 있는 스레드에 작업을 요청하는 방식.

### Prefork MPM
MPM 방식 (Multi Process Module) - prefork
MPM-prework : 멀티 프로세스 방식 마스터 프로세스가 있고 요청이 들어오면 슬레이브 프로세스를 fork 하여 만들고 이 슬레이브 프로세스에서 요청에 대한 처리를 한다.
매 요청에 맞춰서 슬레이브 프로세스를 만들어야 하기때문에 프로세스가 계속 늘어나는 문제점과, 매번 요청에 따라서 슬레이브 프로세스로 바꾸는 context switching 비용이 있다.

### Worker MPM
MPM-worker : 멀티 쓰레드 방식. 위 방식과 거의 유사하며 프로세스 대신 쓰레드를 사용하는 것이 다르다.

풀을 쓴다고 해도 쓰레드, 프로세스 수를 줄이는 것에 대한 근본적인 해결책이 될 수 없음.

apache 는 기본적으로 REQ가 들어오면 그거에 맞춰서 새로운 Process, Thread를 생성한다.

event-driven
reactor pattern

## 6. WAS

## 6. Tomcat

웹서버와 WAS를 구분하는 이유
1. 2티어 구조로 변경함으로써 각자 역할에 대해서 응집도를 높이고 Loose Coupling. 디버깅도 하기 쉬워진다.
2. 성능 향상 - 각자의 서버의 관심사가 몰입되기 때문에  
3. 웹서버 1대 WAS 여러대를 둘때 로드밸런싱을 해주는 역할이 웹서버.

톰캣은 apache의 웹서버의 역할도 가지고 있기 때문에 내부적으로는 웹서버 + 서블릿 컨테이너로 구분된다고 할 수 있따.

웹서버가 처리할 수 없는 동적 컨텐츠에 대한 요청이 들어오면 서블릿 컨테이너에서 이 요청을 처리하기 위한 서블릿을 생성한다.

스프링 MVC에서는 DispatcherServlet 이라는 요소가 있는데 이 녀석이 Servlet을 생성하고 Controller 영역에게 처리를 위임한다.

실제로 DispatcherServlet 이 녀석은 Servlet 인터페이스를 구현한 객체이다. 


## 7. httpd
httpd는 웹 서버의 백그라운드에서 실행되어, 들어오는 서버 요청을 대기하는 소프트웨어 프로그램이다. 이 데몬은 자동으로 요청에 응답하며 HTTP를 사용하여 인터넷을 경유, 하이퍼텍스트, 멀티미디어 문서들을 서비스한다.

## 8. docker, docker-compose, 쿠버네티스

도커의 장점
1. 획일화된 쉽고 빠른 실행 환경 구축
실행환경이 다른 것은 운영되고 있는 서비스에게는 큰 문제가 될 수 있다. 예를 들어 로컬환경과 운영환경이 다른 경우다.
2. 이미지를 통해 환경을 공유할 수 있다.
도커 허브를 통해 다른 개발자들이 구성해둔 개발 환경들을 내려받을 수 있다.
3. 쉬운 배포
파일 반영이 아닌 도커 이미지를 배포하면 되기 때문에 훨씬 좋다.

컨테이너는 애플리케이션을 환경에 구애 받지 않고 실행한느 기술.
-> 예를 들어서 깃랩을 우분투 서버에 올릴때나 센트OS에 올릴때 사용되는 명령어가 다르다. 즉 환경에 어플리케이션이 영향을 받고 있다는 의미.



한번에 여러 개의 docker 들을 관리하는 툴 같다.

Docker Compose 는 간단하게 여러 Docker application 들을 어떻게 실행할지 정의하고 실행할 수 있는 툴입니다

이렇게 local 환경 관리에 Docker Compose 를 이용했을 때 어떤 장점들이 있을까요?

띄우고 내리는 등의 행위가 편하다
Docker 환경이 파일로 관리된다
협업 하는 모두가 명령어 하나로 쉽게 같은 환경을 사용할 수 있게된다

도커는 ‘이미지를 만들고 컨테이너에 띄우는 도구’이고 쿠버네티스는 ‘도커를 관리하는 툴’이다.

도커라는 것은 컨테이너 기반으로 서비스를 운영할 수 있도록 하는 것.
도커의 장점?

쿠버네티스가 가지는 역할


## 9. nosql vs 관계형 db


### SQL과  NoSQL의 개념적 차이
읽기 처리를 자주하지만 데이터를 자주 변경하지 않는경우 nosql이 더 낫다..?

RDB는 스키마가 엄격하다. 스키마에 맞지않는 데이터는 추가할 수 없다.
RDB의 장점은 명확한 구조를 가지기 때문에 즉 엄격한 스키마를 따르기 때문에 테이블에서 데이터의 중복이 발생하지 않으며 (사실 발생하지 않는 구조로 정규화 시켜야 한다. 발생하지 않음을 강제하진 않는다. 단지 그걸 추구할 뿐)
데이터의 정합성을 유지하는 것에 포커스를 가진다. 다른 테이블에서 부정확한 데이터를 다룰 위험이 없다.

No-sql

 SQL 세상에서는 정해진 스키마를 따르지 않는다면 데이터를 추가 할 수 없지만, NoSQL에서는 다른 구조의 데이터를 같은 컬렉션(= SQL에서의 테이블)에 추가할 수 있습니다. 이게 핵심적인 차이인듯

 컬렉션 == 테이블
 다큐먼트 == 로우

 SQL 관점에서 여러 테이블이 조인된 형태로 한 다큐먼트에 저장된다. 그렇기 때문에 실제로 NoSQL 데이터 베이스에는 조인의 개념이 존재하지 않는다.

조인을 하지 않기 때문에 -> 관계를 기준으로 데이터들을 찾는 작업이 없기 때문에 RDB 보다 빠른 것이다.
그러나 데이터의 정합성을 보장하지 않는다.

이런 방식은 데이터가 중복되기 때문에 불안정한 측면이 있습니다. 실수로 컬렉션 B에서는 데이터를 수정하지 않았는데, 컬렉션 A에서만 데이터를 업데이트 할 위험이 있습니다. -> 데이터가 중복되기때문에 발생하는 오류들이 많다.

RDB 에서는 이런 문제가 발생하지 않도록 정규화를 하는데 NoSQL은 이게 없나보다.

### 수직적 확장 & 수평적 확장

수직적 확장 -> 단순히 데이터베이스 서버의 성능을 향상시키는 것.
수평적 확장 -> 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미.

SQL 데이터베이스는 데이터가 저장되는 엄격한 스키마 때문에 수직적 확장만이 가능. 여러 대의 데이터베이스를 가지기가 어렵다.


그럼에도 불구하고, 이러한 방식의 커다란 장점은 복잡하고 (어떤 순간에는 느린) 조인을 사용할 필요가 없다는 것입니다. 

SQL의 장점
명확하게 정의 된 스키마, 데이터 무결성 보장
관계는 각 데이터를 중복없이 한번만 저장됩니다.

NoSQL의 장점
스키마가 없기때문에, 훨씬 더 유연합니다. 즉, 언제든지 저장된 데이터를 조정하고 새로운 "필드"를 추가 할 수 있습니다.
데이터는 애플리케이션이 필요로 하는 형식으로 저장됩니다. 이렇게 하면 데이터를 읽어오는 속도가 빨라집니다.
수직 및 수평 확장이 가능하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기 / 쓰기 요청을 처리 할 수 있습니다.

그리고 단점은 아래와 같습니다.

SQL의 단점
상대적으로 덜 유연합니다. 데이터 스키마는 사전에 계획되고 알려져야 합니다. (나중에 수정하기가 번거롭거나 불가능 할 수 도 있습니다.)
관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있습니다.
수평적 확장이 어렵고, 대체로 수직적 확장만 가능합니다. 즉 어떤 시점에서 (처리 할 수 있는 처리량과 관련하여) 성장 한계에 직면하게 됩니다.

NoSQL의 단점

유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있습니다.
데이터 중복은 여러 컬렉션과 문서가 (SQL 세계에서 처럼 하나의 테이블에 하나의 레코드가 아니라) 여러 개의 레코드가 변경된 경우 업데이트를 해야 합니다.
데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함을 의미합니다. (SQL 세계에서는 중복된 데이터가 없기 때문에 한번만 수행하면 됩니다.)

## mongodb vs redis

redis 는 인 메모리 데이터 구조 저장소. 그러면 이건 디스크에는 저장을 못하나?

Redis는 휘발성 메모리, 즉 RAM에 키-값 쌍으로 데이터를 저장하는 메모리 내 데이터 저장소이며 매우 빠릅니다.
MongoDB 데이터는 디스크에 저장됩니다

Redis는 효율적인 캐시 메커니즘으로 작동하지만 데이터베이스로 redis를 선택 하려면 추가 오버 헤드가 필요합니다. -> 레디스는 전체적인 저장소로 사용하기에는 무리가 있고, 캐싱의 목적으로 쓰는게 맞다고 본다
메모리도 제한되고. 성능을 위해 많은 것들을 포기한 케이스.

Spring의 세션 클러스터링은 기본적으로 Redis를 이용하여 진행됩니다.

NoSQL은 RDBMS에 비해 속도와 확장성이 뛰어납니다. 위 문서를 통해 MySQL과 같은 RDBMS는 속도가 중요한 캐싱에는 적합하지 않다는 것을 알 수 있었습니다.

## Redis, Memcached
Redis는 다양한 데이터 타입을 지원, Memcached 는 String만 지원.
Redis는 디스크에 백업 데이터를 저장.

## ELK (Elasticsearch, Logstash, Kibana, )

Elasticsearch 는 JSON 기반의 분산형 오픈 소스 RESTful 검색 엔진. 예전에 먼가 Redis 처럼 저장소로 생각했는데 그게 아니고 단순히 검색엔진.

로그 수집 파이프라인 -> Logstash
시각화 도구 -> Kibana

## Java Executor


## Spring Framework.

Client에게서 Request이 들어오면. 웹서버를 거치고 WAS로 와서 동적 웹 처리를 위한 Servlet container 영역으로 온다. Servlet container 영역에서 servlet 의 라이프사이클을 관리하는데 Servlet의 구현체인 DispatcherSevlet도 여기서 관리된다.

여기서 Servlet container 는 톰캣 기반 설명임.


Request를 분석하여 매핑된 Controller를 찾는 HandlerMapping 단계를 거치고 있으면 HandlerAdapter 단계에서 Controller를 호출.

Controller에서 view를 return 했을 경우 해당하는 view를 찾아 client에게 return 한다.

## tomcat vs undertow vs netty

undertow
NON-Blocking API와 Bloking API 모두 지원한다.
WAS = 웹서버 + 서블릿 컨테이너.


## Kafka

## RabbitMQ

## CDN (Content Delivery Network)
원거리에 있는 서버의 컨텐츠를 매번 네트워크 상으로 데이터를 받는 것은 성능적인 문제가 있기 때문에. 보다 가깐 곳에 프록시 서버를 두고 캐싱하는 방법을 말하는 것 같음.

CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된(사전 저장된) 버전으로 요청을 처리합니다

인터넷 트래픽의 절반 이상이 CDN(콘텐츠 전송 네트워크)을 통해 전송됩니다. CDN의 목표는 웹 페이지에 대한 요청이 이동해야 하는 물리적 거리를 줄여 요청 제출 시간과 장치에 완전히 로딩되는 웹 페이지 간의 지연 시간을 줄이는 것입니다.

기본적으로 전세계적으로 인터넷을 연결시켜주는 가장 큰 매체는 해저케이블.


## CORS

## RESTful API

Resource State Transfer API

Resource 중심으로 API를 설계한다.

서버에게 Resource 들은 다양하게 있지만 여기서는 주로 모델, 도메인을 의미.

API를 설계할때 도메인을 중심으로 설계한다는 것.

도메인을 조작할 수 있는 CRUD API 를 Http Method에 따라 제공

URI를 활용하여 Resource를 표현.

Open API 가 주로 RESTful API 를 사용.

RESTful API 의 장점 : 클라이언트가 없어도 API를 설계할 수 있따. - 즉 범용적으로 모든 클라이언트들에게 제공 가능한 API를 만듬.
특정 클라이언트를 위한 API 가 아니기 때문에 한 클라이언트에게 맞춰진 API를 만들 수는 없지만 매번 API 개발 요청이 들어왔을 때
새롭게 만들지 않아도 됨.

A B C 도메인이 있을 때 RESTful API는 A 를 조작하기 위한 CRUD API, B, c 모두 제공


## 함수형 프로그래밍.

### 함수를 일급 객체로로 바라봄.

변수나 데이터 구조안에 담을 수 있다.
파라미터로 전달할 수 있다.
반환값으로 사용할 수 있다.

전통적인 자바 언어 진영에서 함수형 프로그래밍은 사실 조금은 낯설다. 기본적으로 OOP를 위해 만들어졌기 때문.
그 사유로 자바에서는 함수가 클래스 없이 만들수가 없다.

java8 이후에 람다, 메소드 참조 문법이 생겨나면서 함수형 프로그래밍이 보편화되기 시작.

함수형 프로그래밍이란. 함수를 일급변수로 볼수 있다는 것.
풀어서 설명하자면. 함수를 값처럼 변수에 저장하고 사용할 수 있다.

함수는 값과 다르게 데이터 그 자체가 아닌 어떠한 처리 동작, 일련의 순서를 표현하는데 이걸 변수에 저장할 수 있다는 의미.
함수형 프로그래밍을 활용하면 기존에는 OOP에서 다형성을 활용해서 해결하던 문제들을 FP 방식으로 보다 심플하게 해결할 수 있음.

예를 들어

항공사 벤더가 다양하게 있고. 이 벤더들이 공통적으로 상품조회, 결제, 예약 같은 기능을 제공.
개념적으로는 동일하지만 실제 구현되는 내용은 다름.

이럴때 OOP는 상품조회, 결제 등을 표준으로 정의하는 interface를 생성하고. 이를 규격으로 각 항공사 벤더들이 이거에 맞춰서 구현함.

이런 문제를 FP는 항공사마다 다른 이런 구현 방법을 파라미터로 넘겨줄 수 있음.

뭔가 개념적으로 동일하고 실제 구현방법이 다를때. OOP적 해결방법이 있고, FP적 해결 방법이있음.

이둘을 그러면 어떻게 구분해야할까.

뭔가 규모가 크다면 OOP를 활용한 방법이 더 맞다고 봄.
근데 만약 심플하다면 FP로 처리.

### 순수함수 

그리고 함수형 프로그래밍은 순수함수를 적극 활용함.

순수함수는 기본적으로 데이터의 불변성을 요구함.
부수효과(Side Effect)가 없는 함수. 즉 어떤 함수에 동일한 값을 주었을 때 항상 같은 값을 반환하는 함수.
입력 값에 대한 결과 값이 항상 동일해야 한다.

즉 한 함수 범위 내에서 동작되는 내용들은 파라미터로 제공된 값만을 활용해서 처리되어야 하며 외부에서 받게되는 데이터들을 최대한 자제한다.

실제로 순수함수 형태로 코드를 짜야 테스트 코드를 작성하기도 쉽다.

### 고차함수, 합성함수

이 내용들은 함수를 일급 객체로써 바라볼 수 있기 때문에 나타나는 내용인데.
함수 안에서 함수를 받을 수 있고 그러면서 서로 조합이 가능하다는 부분이다.


## Call By Value Call By Reference
