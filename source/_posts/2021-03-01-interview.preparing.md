---
layout: post
title:  "Interview Preparing"
date:   2021-03-01 00:0054 +0900
categories: java
---

## 1. Dead Lock (교착상태)

Mutual Exclusion (상호배제)

자원은 한번에 한 프로세스만이 사용할 수 있다.


## 2. Transaction

DBMS는 기본적으로 질의 처리기와 저장 시스템 두 부분으로 나누어진다.

그리고 저장 시스템에 메인 메모리에 유지하는 페이지들을 관리하는 페이지 버퍼라는 모듈이있다.
이 페이지 버퍼라는 모듈이 트랜잭션 과리를 하는데 매우 중요한 결정을 한다.

## 3. IoC (Inversion Of Control)

의존성 주입의 책임을. 개발자에게 넘기는게 아니고. 프레임워크에서 해준다. 제어의 역전이라고 해서 제어의 주체가 개발자가 아닌 프레임워크가 가져갔다는 의미.

의존성 관리라는 것이 커지면 커질수록 꽤나 부담이 되는 요소.

그렇기에 스프링 같은경우 스프링 컨테이너에서 빈들을 등록해두고. 여기서 의존성들을 주입시켜줄수 있또록 한다.

## 4. MVC (Model View Controller)

Model => 데이터를 가공하고 관리하는 영역
Persistant Layer 같은 곳.

View => 타임리프, jsp 같은 뷰 사이드.
여기서 보여지는 데이터들은 이 뷰영역에서 만들어지는 것이 아니고 Controller에서 받는다.

Controller -> 중간에서 Model 과 View 사이에서 매핑해준다.

장점 : MSA 중 하나의 패턴이라고 생각한다. 모듈화가 되기 때문에 어플리케이션의 유연성, 확장성이 증가된다.

## 5. 웹서버

### 멀티쓰레드 방식

#### Prefork MPM
MPM 방식 (Multi Process Module) - prefork
MPM-prework : 멀티 프로세스 방식 마스터 프로세스가 있고 요청이 들어오면 슬레이브 프로세스를 fork 하여 만들고 이 슬레이브 프로세스에서 요청에 대한 처리를 한다.
매 요청에 맞춰서 슬레이브 프로세스를 만들어야 하기때문에 프로세스가 계속 늘어나는 문제점과, 매번 요청에 따라서 슬레이브 프로세스로 바꾸는 context switching 비용이 있다.

#### Worker MPM
MPM-worker : 멀티 쓰레드 방식. 위 방식과 거의 유사하며 프로세스 대신 쓰레드를 사용하는 것이 다르다.


### nginx vs apache (이벤트 루프 vs 멀티쓰레드방식)

apache 웹서버에서 요청을 처리하기 위해 사용하는 쓰레드 기반 모델은 각 클라이언트가 하나의 쓰레드를 물고 처리.
이는 하나의 프로세스가 공통적으로 사용하는 자원이 release 될 때까지 I/O가 blocking 됨.
또한 더 많은 자원을 필요로 함 (Context Switching 비용이 큼)

아파치 웹 서버는 구조적으로 멀티 스레드/멀티 프로세스 기반으로 동작. 클라이언트의 요청이 들어오면 스레드를 생성하거나 혹은 이미 만들어져 있는 스레드에 작업을 요청하는 방식.

### Prefork MPM
MPM 방식 (Multi Process Module) - prefork
MPM-prework : 멀티 프로세스 방식 마스터 프로세스가 있고 요청이 들어오면 슬레이브 프로세스를 fork 하여 만들고 이 슬레이브 프로세스에서 요청에 대한 처리를 한다.
매 요청에 맞춰서 슬레이브 프로세스를 만들어야 하기때문에 프로세스가 계속 늘어나는 문제점과, 매번 요청에 따라서 슬레이브 프로세스로 바꾸는 context switching 비용이 있다.

### Worker MPM
MPM-worker : 멀티 쓰레드 방식. 위 방식과 거의 유사하며 프로세스 대신 쓰레드를 사용하는 것이 다르다.

풀을 쓴다고 해도 쓰레드, 프로세스 수를 줄이는 것에 대한 근본적인 해결책이 될 수 없음.

apache 는 기본적으로 REQ가 들어오면 그거에 맞춰서 새로운 Process, Thread를 생성한다.

event-driven
reactor pattern

## 6. WAS

웹서버와 WAS를 구분하는 이유
1. 2티어 구조로 변경함으로써 각자 역할에 대해서 응집도를 높이고 Loose Coupling. 디버깅도 하기 쉬워진다.
2. 성능 향상 - 각자의 서버의 관심사가 몰입되기 때문에  
3. 웹서버 1대 WAS 여러대를 둘때 로드밸런싱을 해주는 역할이 웹서버.

톰캣은 apache의 웹서버의 역할도 가지고 있기 때문에 내부적으로는 웹서버 + 서블릿 컨테이너로 구분된다고 할 수 있따.

웹서버가 처리할 수 없는 동적 컨텐츠에 대한 요청이 들어오면 서블릿 컨테이너에서 이 요청을 처리하기 위한 서블릿을 생성한다.

스프링 MVC에서는 DispatcherServlet 이라는 요소가 있는데 이 녀석이 Servlet을 생성하고 Controller 영역에게 처리를 위임한다.

실제로 DispatcherServlet 이 녀석은 Servlet 인터페이스를 구현한 객체이다. 

### tomcat vs undertow vs netty

undertow
NON-Blocking API와 Bloking API 모두 지원한다.
WAS = 웹서버 + 서블릿 컨테이너.


## 7. httpd
httpd는 웹 서버의 백그라운드에서 실행되어, 들어오는 서버 요청을 대기하는 소프트웨어 프로그램이다. 이 데몬은 자동으로 요청에 응답하며 HTTP를 사용하여 인터넷을 경유, 하이퍼텍스트, 멀티미디어 문서들을 서비스한다.

## 8. docker, docker-compose, 쿠버네티스

도커의 장점
1. 획일화된 쉽고 빠른 실행 환경 구축
실행환경이 다른 것은 운영되고 있는 서비스에게는 큰 문제가 될 수 있다. 예를 들어 로컬환경과 운영환경이 다른 경우다.
2. 이미지를 통해 환경을 공유할 수 있다.
도커 허브를 통해 다른 개발자들이 구성해둔 개발 환경들을 내려받을 수 있다.
3. 쉬운 배포
파일 반영이 아닌 도커 이미지를 배포하면 되기 때문에 훨씬 좋다.

컨테이너는 애플리케이션을 환경에 구애 받지 않고 실행한느 기술.
-> 예를 들어서 깃랩을 우분투 서버에 올릴때나 센트OS에 올릴때 사용되는 명령어가 다르다. 즉 환경에 어플리케이션이 영향을 받고 있다는 의미.



한번에 여러 개의 docker 들을 관리하는 툴 같다.

Docker Compose 는 간단하게 여러 Docker application 들을 어떻게 실행할지 정의하고 실행할 수 있는 툴입니다

이렇게 local 환경 관리에 Docker Compose 를 이용했을 때 어떤 장점들이 있을까요?

띄우고 내리는 등의 행위가 편하다
Docker 환경이 파일로 관리된다
협업 하는 모두가 명령어 하나로 쉽게 같은 환경을 사용할 수 있게된다

도커는 ‘이미지를 만들고 컨테이너에 띄우는 도구’이고 쿠버네티스는 ‘도커를 관리하는 툴’이다.

도커라는 것은 컨테이너 기반으로 서비스를 운영할 수 있도록 하는 것.
도커의 장점?

쿠버네티스가 가지는 역할

## 9. SQL vs NoSQL

읽기 처리를 자주하지만 데이터를 자주 변경하지 않는경우 nosql이 더 낫다..?

RDB는 스키마가 엄격하다. 스키마에 맞지않는 데이터는 추가할 수 없다.
RDB의 장점은 명확한 구조를 가지기 때문에 즉 엄격한 스키마를 따르기 때문에 테이블에서 데이터의 중복이 발생하지 않으며 (사실 발생하지 않는 구조로 정규화 시켜야 한다. 발생하지 않음을 강제하진 않는다. 단지 그걸 추구할 뿐)
데이터의 정합성을 유지하는 것에 포커스를 가진다. 다른 테이블에서 부정확한 데이터를 다룰 위험이 없다.

No-sql

 SQL 세상에서는 정해진 스키마를 따르지 않는다면 데이터를 추가 할 수 없지만, NoSQL에서는 다른 구조의 데이터를 같은 컬렉션(= SQL에서의 테이블)에 추가할 수 있습니다. 이게 핵심적인 차이인듯

 컬렉션 == 테이블
 다큐먼트 == 로우

 SQL 관점에서 여러 테이블이 조인된 형태로 한 다큐먼트에 저장된다. 그렇기 때문에 실제로 NoSQL 데이터 베이스에는 조인의 개념이 존재하지 않는다.

조인을 하지 않기 때문에 -> 관계를 기준으로 데이터들을 찾는 작업이 없기 때문에 RDB 보다 빠른 것이다.
그러나 데이터의 정합성을 보장하지 않는다.

이런 방식은 데이터가 중복되기 때문에 불안정한 측면이 있습니다. 실수로 컬렉션 B에서는 데이터를 수정하지 않았는데, 컬렉션 A에서만 데이터를 업데이트 할 위험이 있습니다. -> 데이터가 중복되기때문에 발생하는 오류들이 많다.

RDB 에서는 이런 문제가 발생하지 않도록 정규화를 하는데 NoSQL은 이게 없나보다.

## 10. 수직적 확장 & 수평적 확장

수직적 확장 -> 단순히 데이터베이스 서버의 성능을 향상시키는 것.
수평적 확장 -> 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미.

SQL 데이터베이스는 데이터가 저장되는 엄격한 스키마 때문에 수직적 확장만이 가능. 여러 대의 데이터베이스를 가지기가 어렵다.


그럼에도 불구하고, 이러한 방식의 커다란 장점은 복잡하고 (어떤 순간에는 느린) 조인을 사용할 필요가 없다는 것입니다. 

SQL의 장점
명확하게 정의 된 스키마, 데이터 무결성 보장
관계는 각 데이터를 중복없이 한번만 저장됩니다.

NoSQL의 장점
스키마가 없기때문에, 훨씬 더 유연합니다. 즉, 언제든지 저장된 데이터를 조정하고 새로운 "필드"를 추가 할 수 있습니다.
데이터는 애플리케이션이 필요로 하는 형식으로 저장됩니다. 이렇게 하면 데이터를 읽어오는 속도가 빨라집니다.
수직 및 수평 확장이 가능하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기 / 쓰기 요청을 처리 할 수 있습니다.

그리고 단점은 아래와 같습니다.

SQL의 단점
상대적으로 덜 유연합니다. 데이터 스키마는 사전에 계획되고 알려져야 합니다. (나중에 수정하기가 번거롭거나 불가능 할 수 도 있습니다.)
관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있습니다.
수평적 확장이 어렵고, 대체로 수직적 확장만 가능합니다. 즉 어떤 시점에서 (처리 할 수 있는 처리량과 관련하여) 성장 한계에 직면하게 됩니다.

NoSQL의 단점

유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있습니다.
데이터 중복은 여러 컬렉션과 문서가 (SQL 세계에서 처럼 하나의 테이블에 하나의 레코드가 아니라) 여러 개의 레코드가 변경된 경우 업데이트를 해야 합니다.
데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함을 의미합니다. (SQL 세계에서는 중복된 데이터가 없기 때문에 한번만 수행하면 됩니다.)

## 11. mongodb vs redis

redis 는 인 메모리 데이터 구조 저장소. 그러면 이건 디스크에는 저장을 못하나?

Redis는 휘발성 메모리, 즉 RAM에 키-값 쌍으로 데이터를 저장하는 메모리 내 데이터 저장소이며 매우 빠릅니다.
MongoDB 데이터는 디스크에 저장됩니다

Redis는 효율적인 캐시 메커니즘으로 작동하지만 데이터베이스로 redis를 선택 하려면 추가 오버 헤드가 필요합니다. -> 레디스는 전체적인 저장소로 사용하기에는 무리가 있고, 캐싱의 목적으로 쓰는게 맞다고 본다
메모리도 제한되고. 성능을 위해 많은 것들을 포기한 케이스.

Spring의 세션 클러스터링은 기본적으로 Redis를 이용하여 진행됩니다.

NoSQL은 RDBMS에 비해 속도와 확장성이 뛰어납니다. 위 문서를 통해 MySQL과 같은 RDBMS는 속도가 중요한 캐싱에는 적합하지 않다는 것을 알 수 있었습니다.

## 12. Redis, Memcached

Redis는 다양한 데이터 타입을 지원, Memcached 는 String만 지원.
Redis는 디스크에 백업 데이터를 저장.

## 13. ELK (Elasticsearch, Logstash, Kibana)

Elasticsearch 는 JSON 기반의 분산형 오픈 소스 RESTful 검색 엔진. 예전에 먼가 Redis 처럼 저장소로 생각했는데 그게 아니고 단순히 검색엔진.

그러면 데이터는 어디에 저장이 되어 있는 거지? 내부에 자체적으로 저장소를 가지는 거 같다.

ES는 JVM위에서 구동되기 때문에 JDK를 설치해야 합니다. 자바로 구현되어 있다. 1.8 이상의 버전을 활용해야 한다.


Elasticsearch 용어

Database = Index
Table = Type
Row = Document
Column = Field
Index = Analyze
Primary Key = _id
Schema = Mapping
Physical partition = Shard
Local Partition = Route
SQL = Query DSL

클러스터 - elasticsearch 에서 가장 큰 시스템 단위를 의미. 최소 하나 이상의 노드로 이루어짐. 클러스터간 데이터 접근,교환이 불가능.

인덱스 - RDBMS에서 데이터베이스에 대응되는 개념.

샤드 - 데이터를 분산해서 저장하는 방법 (파티션 같은 느낌). 스케일 아웃을 위해서 index를 여러 shard로 쪼갠 것.

elasticsearch 특징

scale out - 샤드를 통해서 규모가 수평적으로 늘어날 수 있다.

schema free - json 문서를 통해 데이터 검색을 수행함으로 스키마 개념이 없다.

restful - 데이터 CRUD 작업은 HTTP Method 에 맞춰서 수행된다.

elasticsearch가 강점을 보이는 부분은 문장이나 여러 단어들의 조합이 저장될 때이다. 문장은 여러 단어들로 구성이 되어있고 그 중 중요한 키워도 있고 큰 의미가 없는 단어들도 있다. elasticsearch는 데이터를 저장할 때 의미있는 단어들을 추출해 해당 단어들로 inverted index를 생성한다.

elasticsearch는 수많은 analyzer와 tokenizer가 존재하는데 이를 잘 활용해야 elasticsearch를 제대로 활용한다 볼 수 있다.

#### Logstash

로그 수집 파이프라인 -> Logstash

## 운영체제 - 파이프라인
차를 만들떄 분업을 하는데 차체를 만들고,안에 엔진을 만들고, 도색을하고 여러 단계를 거치지.

근데 차를 만들어달라는 요구가 들어옴.
5단계의 업무들이 차 한대에 대해서 집중을함. 그래서 만약에 1단계에서 업무를 하고있으면 다른 단계들이 idle 상태이다. 놀고있다는 의미. 비효율적.

파이프 라인 구조는 다른 단계가 어떤 상태인지는 고려안하고 단지 요구사항 즉 업무가 들어오면 자신의 일을 바로바로 처리하는 구조.

파이프라인 구조.

## pipeline hazard
구조적 해저드. structural hazard
다른 단계에 있는 명령어들이 동시에 같은 자원을 사용하려고 하는 상황 -> 해당 자원을 여러개 설치하는 방법으로 해결.

데이터 해저드. data hazard
앞 명령어 결과를 사용해야 하는데 앞이 아직 끝이 안나서 그 결과를 사용 못하는 상황 -> 파이프라인 지연, 전발전달로 해결


시각화 도구 -> Kibana

## 14. Java Executor


## 15. Spring Framework.

Client에게서 Request이 들어오면. 웹서버를 거치고 WAS로 와서 동적 웹 처리를 위한 Servlet container 영역으로 온다. Servlet container 영역에서 servlet 의 라이프사이클을 관리하는데 Servlet의 구현체인 DispatcherSevlet도 여기서 관리된다.

여기서 Servlet container 는 톰캣 기반 설명임.


Request를 분석하여 매핑된 Controller를 찾는 HandlerMapping 단계를 거치고 있으면 HandlerAdapter 단계에서 Controller를 호출.

Controller에서 view를 return 했을 경우 해당하는 view를 찾아 client에게 return 한다.


## 16. Kafka

## 17. RabbitMQ

## 18. CDN (Content Delivery Network)
원거리에 있는 서버의 컨텐츠를 매번 네트워크 상으로 데이터를 받는 것은 성능적인 문제가 있기 때문에. 보다 가깐 곳에 프록시 서버를 두고 캐싱하는 방법을 말하는 것 같음.

CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된(사전 저장된) 버전으로 요청을 처리합니다

인터넷 트래픽의 절반 이상이 CDN(콘텐츠 전송 네트워크)을 통해 전송됩니다. CDN의 목표는 웹 페이지에 대한 요청이 이동해야 하는 물리적 거리를 줄여 요청 제출 시간과 장치에 완전히 로딩되는 웹 페이지 간의 지연 시간을 줄이는 것입니다.

기본적으로 전세계적으로 인터넷을 연결시켜주는 가장 큰 매체는 해저케이블.


## 19. CORS

## 20. RESTful API

Resource State Transfer API

Resource 중심으로 API를 설계한다.

서버에게 Resource 들은 다양하게 있지만 여기서는 주로 모델, 도메인을 의미.

API를 설계할때 도메인을 중심으로 설계한다는 것.

도메인을 조작할 수 있는 CRUD API 를 Http Method에 따라 제공

URI를 활용하여 Resource를 표현.

Open API 가 주로 RESTful API 를 사용.

RESTful API 의 장점 : 클라이언트가 없어도 API를 설계할 수 있따. - 즉 범용적으로 모든 클라이언트들에게 제공 가능한 API를 만듬.
특정 클라이언트를 위한 API 가 아니기 때문에 한 클라이언트에게 맞춰진 API를 만들 수는 없지만 매번 API 개발 요청이 들어왔을 때
새롭게 만들지 않아도 됨.

A B C 도메인이 있을 때 RESTful API는 A 를 조작하기 위한 CRUD API, B, c 모두 제공


## 21. 함수형 프로그래밍.

### 일급 함수.

변수나 데이터 구조안에 담을 수 있다.
파라미터로 전달할 수 있다.
반환값으로 사용할 수 있다.

전통적인 자바 언어 진영에서 함수형 프로그래밍은 사실 조금은 낯설다. 기본적으로 OOP를 위해 만들어졌기 때문.
그 사유로 자바에서는 함수가 클래스 없이 만들수가 없다.

java8 이후에 람다, 메소드 참조 문법이 생겨나면서 함수형 프로그래밍이 보편화되기 시작.

함수형 프로그래밍이란. 함수를 일급변수로 볼수 있다는 것.
풀어서 설명하자면. 함수를 값처럼 변수에 저장하고 사용할 수 있다.

함수는 값과 다르게 데이터 그 자체가 아닌 어떠한 처리 동작, 일련의 순서를 표현하는데 이걸 변수에 저장할 수 있다는 의미.
함수형 프로그래밍을 활용하면 기존에는 OOP에서 다형성을 활용해서 해결하던 문제들을 FP 방식으로 보다 심플하게 해결할 수 있음.

예를 들어

항공사 벤더가 다양하게 있고. 이 벤더들이 공통적으로 상품조회, 결제, 예약 같은 기능을 제공.
개념적으로는 동일하지만 실제 구현되는 내용은 다름.

이럴때 OOP는 상품조회, 결제 등을 표준으로 정의하는 interface를 생성하고. 이를 규격으로 각 항공사 벤더들이 이거에 맞춰서 구현함.

이런 문제를 FP는 항공사마다 다른 이런 구현 방법을 파라미터로 넘겨줄 수 있음.

뭔가 개념적으로 동일하고 실제 구현방법이 다를때. OOP적 해결방법이 있고, FP적 해결 방법이있음.

이둘을 그러면 어떻게 구분해야할까.

뭔가 규모가 크다면 OOP를 활용한 방법이 더 맞다고 봄.
근데 만약 심플하다면 FP로 처리.

### 순수 함수 

그리고 함수형 프로그래밍은 순수함수를 적극 활용함.

순수함수는 기본적으로 데이터의 불변성을 요구함.
부수효과(Side Effect)가 없는 함수. 즉 어떤 함수에 동일한 값을 주었을 때 항상 같은 값을 반환하는 함수.
입력 값에 대한 결과 값이 항상 동일해야 한다.

즉 한 함수 범위 내에서 동작되는 내용들은 파라미터로 제공된 값만을 활용해서 처리되어야 하며 외부에서 받게되는 데이터들을 최대한 자제한다.

실제로 순수함수 형태로 코드를 짜야 테스트 코드를 작성하기도 쉽다.

쓰레드에도 안전하다. 객체에 값을 넣어놓고 함수에서 이를 호출하는 구조로 만들게 되면. 이 객체들은
멀티쓰레드 환경이 되었을 때 각 쓰레드에 의해서 공유되는 데이터가 된다.
그래서 이 데이터가 thread-safe하도록 추가적인 작업이 필요하다.

순수함수 패러다임을 사용할 수 없는 경우는 값을 stateful 해야하는 경우다.
예를 들면 빌더패턴이나 java의 stream 기능같은 것이다.


### 고차함수, 합성함수

이 내용들은 함수를 일급 객체로써 바라볼 수 있기 때문에 나타나는 내용인데.
함수 안에서 함수를 받을 수 있고 그러면서 서로 조합이 가능하다는 부분이다.


## 22. Call By Value Call By Reference

## 23. Stack

세로로된 바구니같은 구조. 밑에있는 데이터들은 위에있는 데이터가 빠져나가야만 빼낼 수 있다.
즉 먼저 넣는 자료가 마지막으로 나오게 되는 First In Last Out (FILO), 선입선출 구조.

### 프로세서 사이클 (메이저 사이클)

CPU가 동작하는 기본적인 원리는 메이저 사이클 혹은 프로세스 사이클 따른다.

명령어 인출 -> 명령어 해독 -> 오퍼랜드 인출 -> 실행 -> 인터럽트 조사

인터럽트가 걸리게 되면 Stack 구조로 구현된 저장소에 이전 프로세스의 메모리 번지를 저장시키고 인터럽트 걸린 프로세스를 시작한다.
이게 해결이 되면 해결된 프로세스는 pop 하고 그 아래에 있는 프로세스가 다시 시작.

스택은 CPU가 명령어들을 수행할 때 가장 기본적으로 사용하는 구조.

## 24. 인터럽트 vs 폴링

지금하고 있는 프로세스보다 더 중요한 프로세스가 등장하게 되면 더 중요한 프로세스를 처리하게 되는데.
이러한 것이 새로운게 기존것을 방해한거로 생각되어 인터럽트 걸렸다라고 표현한다.

각 CPU 인터럽트의 우선순위가 정해져 있음.

인터럽트 벡터 : 인터럽트가 발생했을 때 해야할 일을 정해놓은 것으로 바로 인터럽트 서비스 루틴의 시작 주소. 메모리 번지.

폴링 방법은 계속 대기하는 방법

 "폴링"은 한 프로그램이나 장치에서 다른 프로그램이나 장치들이 어떤 상태에 있는지를 지속적으로 체크하는 전송제어 방식

시스템 내에 동작 중에 폴링 방식과 이벤트 방식이 있다. 폴링 방식은 어떤 상태인지를 주기적으로 확인해보는 것이다. 폴링 방식을 예를 든다면 우편물이 왔는지를 매번 내가 가서 보는 것이다. 이렇게 매번 오가는게 폴링이다. 주기적으로 알아보는 만큼 오지 않았을 때 나가보는 동안 비효율이 발생을 한다.

이벤트 방식은 어떤 상태가 되면 알려주는 것이다. 매번 가는 것이 아니라 우편물이 도착했을 때 문자를 보내는 것이다. 훨씬 효율적일 수 있다. 이벤트 방식로 해당 사람이 오면 알려 주는 방식이다. 두 방식에는 차이가 있지만, 언듯 폴링 방식은 비효율적일 거 같다는 생각을 할 수 있다. 하지만 정기적으로 뭔가를 감시하거나 검사를 해야 한다면 폴링방식도 필요할 것이다. 하지만 이벤트 방식을 통해서 트리거를 발생 시켜서 인지를 하게 되면 그 비효율이 줄어들어서 효율적으로 처리 할 수 있다.

## 25. 큐

가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조이다.

## 26. 해시

해시 테이블은 key, value 타입의 데이터를 저장하는 자료구조.

key 값을 해시함수로 생성하는데 이 key 값이 해시테이블 크기만큼 우선 고유하게 만든다.
만약 데이터가 이 해시테이블보다 많다면 이 key 값이 중복될 수도 있다.

해시값이 중복된 경우 연결리스트 구조로 데이터가 저장이 되며 그 안에서 탐색을 한다.
해시테이블보다 데이터 양이 작다면 시간복잡도는 O(1) 이 되며.
시간 복잡도를 공간복잡도로 바꾼 형태라고 볼 수 있다.

해시 값을 생성할때 중요한 포인트는 해시코드가 골고루 분포할 수 있도록 하는게 중요하다.
해시코드가 특정 코드에 집중되있다면 해시테이블의 기능을 효과적으로 이용할 수 없다.

## 27. 리스트

### 배열리스트

데이터를 추가/삭제하는데에는 배열리스트가 데이터를 밀고 당기고 해야하기 떄문에 추가적인 연산작업이 있어 오래걸린다.

데이터를 검색할 때에는 단순히 해당 번지를 조회하면 되기 때문에 연결리스트 보다 빠르다.

### 연결리스트

데이터를 추가/삭제할 때 노드가 가리키는 대상만 바꿔주면 되어 배열리스트에 비해 빠르다.

데이터를 검색할 때에는 순차접근만 가능하기 때문에 느리다.

## 28. 우선순위 큐

기본적으로 큐는 FIFO 구조로 먼저 들어간 데이터가 먼저 나와야 한다.

우선순위 큐는 기본적으로 큐 형태지만. 우선순위를 고려하고. 우선순위가 더 높은 값이 있다면 그 데이터를 먼저 처리한다.

보통 우선순위 큐를 구현하기 위해서 힙 구조를 활용한다.

삽입: 데이터가 들어오면 각 노드별로 들어온 데이터가 크거나 작은지를 비교하고 정책에 따라서 크면 왼쪽 노드로 작으면 오른쪽 노드로 진행된다.


## 29. 힙

최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 값이 우선순위가 자식노드 보다 높은 구조다.

모든 노드에 저장된 값(우선순위)들은 자식 노드들의 것보다 (우선순위가) 크거나 같다.

따라서 힙은 루트 노드에 우선순위가 가장 높은 데이터를 위치시키는 구조가 됨.

삽입 : 새로들어오는 데이터를 우선순위가 가장 낮다고 가정하고 가장 단말 노드에 추가한다. 그 후에 부모노드와 값을 비교하면서
우선순위가 맞게 될때까지 반복. 새로 들어온 값의 우선순위가 부모보다 낮으면 끝.

삭제 : 루트노드가 제거되고 난 후. 가장 우선순위가 낮은 데이터를 루트노드로 옮긴다. 그리고 자식노드들과 우선순위를 비교하면서 swap



## 30. TCP 3 way-handshake

## 31. ARP (Address Resolution Protocol)

Data Link 계층에서 각 함소들끼리 데이터를 주고받고 연결하는 기준은 바로 맥어드레스.
이 맥어드레스는 NIC (Network Interface Card) 가 고유하게 가지고 있따.

IP로 실제로 통신하는게 아니고 맥어드레스를 기준으로 통신을 함. 그렇기 때문에
IP를 맥어드레스로 바꿔주는 과정이 필요한데 이게 ARP 프로토콜.

맥주소는 기본적으로 48비트

## 32. 패킷

데이터를 통신망을 통해 전송하기 쉽도록 자른 데이터 전송 단위.

## 33. 경력기간동안 진행한 업무를 어필

### 신규 항공사 API 연동 서버 구축.

OTA(Online Travel Agency) 서비스를 하는 부서에서 업무를 함 여기서 주요 상품들은 항공권인데,
실시간 항공권 예매 시스템에서 가져야할 대표적인 기능들이 상품조회, 예약, 발권, 결제, 취소 정도가 있음.
이거가 항공사 벤더마다 다른 형태로 구현이 되어있어서 이를 하나의 인터페이스로 추상화, 표준화를 하고 클라이언트가 항공사 벤더를 신경쓰지 않고 추상화된 규격을 기준으로 비지니스 로직을 작성할 수 있도록 하였음.

기존 API 서버는 항공사 상품조회 연동을 실시간적으로 가져오도록 구현되어 있었음. 항공사가 총 8곳, 평균적으로 항공상품을 가져오는데 3~4초 정도 소요가 되었는데. 매번 연동하는 방식보다. 레디스 캐쉬 서버를 두고. 클라이언트들은 이곳에서 스케줄 정보를 가져올 수 있도록 하고. 레디스 캐쉬 서버에서 각 항공사에 주기적으로 상품조회를 함.

## 34. TCP vs UDP

OSI 7Layer 중 4계층에서 많이 사용되는 두 프로토콜.

TCP
Streaming 서비스에 불리하다. (손실된 경우 재전송 요청을 하므로)

## Spring 기초지식 (DI, DL, AOP)

## GC

### Stop-The-World
GC를 실행하기 위해서 JVM이 그 위에서 동작하는 어플리케이션의 실행을 멈추는 것.

top-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다

대개의 경우 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것이다.

gc는 말그대로 Garbage Collection을 수행하여 불필요한 Obejct를 Memory 상에서 제거하는 것을 의미합니다.

System.gc() 가 안좋은 이유.


## JVM

JVM의 구성인 Young 영역, Old 영역

모든 객체가 쓰레기인지 검사하는 무식한 방식의 가비지 컬렉션은 규모가 큰 프로그램에서 심각한 문제가 생길 수 있다.

JVM GC 설계자들은 경험적으로 대부분의 객체가 생겨나자마자 쓰레기가 된다는 것을 알고 있었다.

이것을 '약한 세대 가설(weak generational hypothesis)'이라 부른다.
따라서 매번 전체를 검사하지 않고 일부만 검사할 수 있도록 generational한 구조를 고안해 내었다.

young generation
객체 대부분이 생성될 때 이곳으로 들어간다.
이곳이 가득차면 minor gc가 발생한다.

minor gc가 발생하면 살아있는 객체들만 체크하고 나머지는 다 없애버린다.
살아남은 객체들 중 더 오래 쓸 것 같은 것들은 tenured generation으로 옮긴다.

tenured generation
이곳이 가득 차면 major gc가 발생한다.
major gc는 minor gc보다 더 오래 걸린다.


Young 영역(Yong Generation 영역): 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.

Young 영역은 다시 3가지로 나뉨.
Eden 영역
Survivor 영역 2개 - 서로 계속 스왑함.
Eden -> Survivor로 가며, Survivor에서도 계속 살아나면 old 영역으로 간다.

Old 영역(Old Generation 영역): 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다.

Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행한다.

Serial GC - Serial GC는 데스크톱의 CPU 코어가 하나만 있을 때 사용하기 위해서 만든 방식이다. Serial GC를 사용하면 애플리케이션의 성능이 많이 떨어진다.

Parallel GC - Parallel GC는 Serial GC와 기본적인 알고리즘은 같지다. 그러나 Serial GC는 GC를 처리하는 스레드가 하나인 것에 비해, Parallel GC는 GC를 처리하는 쓰레드가 여러 개이다. 그렇기 때문에 Serial GC보다 빠른게 객체를 처리할 수 있다. Parallel GC는 메모리가 충분하고 코어의 개수가 많을 때 유리하다. Parallel GC는 Throughput GC라고도 부른다.

Parallel Old GC(Parallel Compacting GC)
Concurrent Mark & Sweep GC(이하 CMS)
G1(Garbage First) GC

## default 메소드

## Spring AOP
AOP 는 OOP 설계론이 가지는 단점을 커버하기 위해 생겨난 방법.

객체 중심으로 디자인하기 때문에. 모든 객체들이 가지는 공통 속성에 대해서 중복이 일어난다.

## Spring IOC
IoC란 말 그대로 제어의 역전. 즉 제어권이 바뀌었다는 것.
개발자가 객체의 생성, 의존성 관리를 직접하는게 아니고 프레임워크, 컨테이너에서 대신 해준다는 의미.

이로 인해 개발자가 직접 객체를 관리해야하는 코드들을 줄일 수 있다

## Spring DL (Dependency Lookup)
Dependency Lookup - 의존대서을 검색을 통해 반환받는 방식
ex) factory.getBean(id);

DL은 의존성 검색이다. 이는 빈에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 Lookup하는 것이다.

## Spring DI (Dependency Injection)
DI는 의존성 주입. 이는 각 클래스 간에 의존성을 자신이 아닌 외부에서 주입하는 개념.

의존성 주입을 사용하게 되면 객체 주입을 외부에서 하기 때문에 보다 유연한 코드를 작성할 수 있다.

## TDD (Test Driven Development)

테스트 주도 개발은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나이다. 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다. 그런 후에, 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다. 마지막으로 작성한 코드를 표준에 맞도록 리팩토링한다. 이 기법을 개발했더나 '재발견' 한 것으로 인정되는 켄트 백은 2003년에 TDD가 단순한 설계를 장려하고 자신감을 불어넣어준다고 말한다.

##


## mod_jk

## 캐시

시간적 지역성
한번 액세스한 메모리는 가까운 미래에 다시 액세스할 가능성이 높다.

공간적 지역성
한번 액세스한 메모리 주변은 가까운 미래에 액세스할 가능성이 높다.

## 데이터베이스 인덱스
B+ Tree 구조로 별도의 인덱스 테이블을 만듬.
