---
layout: post
title:  "Interview Preparing"
date:   2021-03-01 00:0054 +0900
categories: java
---

## 1. 데드락 (교착상태)

Mutual Exclusion (상호배제)

자원은 한번에 한 프로세스만이 사용할 수 있따.


## 2. Transaction

DBMS는 기본적으로 질의 처리기와 저장 시스템 두 부분으로 나누어진다.

그리고 저장 시스템에 메인 메모리에 유지하는 페이지들을 관리하는 페이지 버퍼라는 모듈이있다.
이 페이지 버퍼라는 모듈이 트랜잭션 과리를 하는데 매우 중요한 결정을 한다.

## 3. IoC (Inversion Of Control)

의존성 주입의 책임을. 개발자에게 넘기는게 아니고. 프레임워크에서 해준다. 제어의 역전이라고 해서 제어의 주체가 개발자가 아닌 프레임워크가 가져갔다는 의미.

의존성 관리라는 것이 커지면 커질수록 꽤나 부담이 되는 요소.

그렇기에 스프링 같은경우 스프링 컨테이너에서 빈들을 등록해두고. 여기서 의존성들을 주입시켜줄수 있또록 한다.

## 4. MVC (Model View Controller)

Model => 데이터를 가공하고 관리하는 영역
Persistant Layer 같은 곳.

View => 타임리프, jsp 같은 뷰 사이드.
여기서 보여지는 데이터들은 이 뷰영역에서 만들어지는 것이 아니고 Controller에서 받는다.

Controller -> 중간에서 Model 과 View 사이에서 매핑해준다.

장점 : MSA 중 하나의 패턴이라고 생각한다. 모듈화가 되기 때문에 어플리케이션의 유연성, 확장성이 증가된다.

## 5. nginx, apache

### 멀티쓰레드방식 vs 이벤트 루프

apache 웹서버에서 요청을 처리하기 위해 사용하는 쓰레드 기반 모델은 각 클라이언트가 하나의 쓰레드를 물고 처리.
이는 하나의 프로세스가 공통적으로 사용하는 자원이 release 될 때까지 I/O가 blocking 됨.
또한 더 많은 자원을 필요로 함 (Context Switching 비용이 큼)

아파치 웹 서버는 구조적으로 멀티 스레드/멀티 프로세스 기반으로 동작. 클라이언트의 요청이 들어오면 스레드를 생성하거나 혹은 이미 만들어져 있는 스레드에 작업을 요청하는 방식.



### Prefork MPM
MPM 방식 (Multi Process Module) - prefork
MPM-prework : 멀티 프로세스 방식 마스터 프로세스가 있고 요청이 들어오면 슬레이브 프로세스를 fork 하여 만들고 이 슬레이브 프로세스에서 요청에 대한 처리를 한다.
매 요청에 맞춰서 슬레이브 프로세스를 만들어야 하기때문에 프로세스가 계속 늘어나는 문제점과, 매번 요청에 따라서 슬레이브 프로세스로 바꾸는 context switching 비용이 있다.

### Worker MPM
MPM-worker : 멀티 쓰레드 방식. 위 방식과 거의 유사하며 프로세스 대신 쓰레드를 사용하는 것이 다르다.

풀을 쓴다고 해도 쓰레드, 프로세스 수를 줄이는 것에 대한 근본적인 해결책이 될 수 없음.

apache 는 기본적으로 REQ가 들어오면 그거에 맞춰서 새로운 Process, Thread를 생성한다.

event-driven
reactor pattern

## 6. Tomcat

웹서버와 WAS를 구분하는 이유
1. 2티어 구조로 변경함으로써 각자 역할에 대해서 응집도를 높이고 Loose Coupling. 디버깅도 하기 쉬워진다.
2. 성능 향상 - 각자의 서버의 관심사가 몰입되기 때문에  
3. 웹서버 1대 WAS 여러대를 둘때 로드밸런싱을 해주는 역할이 웹서버.

톰캣은 apache의 웹서버의 역할도 가지고 있기 때문에 내부적으로는 웹서버 + 서블릿 컨테이너로 구분된다고 할 수 있따.

웹서버가 처리할 수 없는 동적 컨텐츠에 대한 요청이 들어오면 서블릿 컨테이너에서 이 요청을 처리하기 위한 서블릿을 생성한다.

스프링 MVC에서는 DispatcherServlet 이라는 요소가 있는데 이 녀석이 Servlet을 생성하고 Controller 영역에게 처리를 위임한다.

실제로 DispatcherServlet 이 녀석은 Servlet 인터페이스를 구현한 객체이다. 


## 7. httpd
httpd는 웹 서버의 백그라운드에서 실행되어, 들어오는 서버 요청을 대기하는 소프트웨어 프로그램이다. 이 데몬은 자동으로 요청에 응답하며 HTTP를 사용하여 인터넷을 경유, 하이퍼텍스트, 멀티미디어 문서들을 서비스한다.

## 8. docker, docker-compose, 쿠버네티스

도커의 장점
1. 획일화된 쉽고 빠른 실행 환경 구축
실행환경이 다른 것은 운영되고 있는 서비스에게는 큰 문제가 될 수 있다. 예를 들어 로컬환경과 운영환경이 다른 경우다.
2. 이미지를 통해 환경을 공유할 수 있다.
도커 허브를 통해 다른 개발자들이 구성해둔 개발 환경들을 내려받을 수 있다.
3. 쉬운 배포
파일 반영이 아닌 도커 이미지를 배포하면 되기 때문에 훨씬 좋다.

컨테이너는 애플리케이션을 환경에 구애 받지 않고 실행한느 기술.
-> 예를 들어서 깃랩을 우분투 서버에 올릴때나 센트OS에 올릴때 사용되는 명령어가 다르다. 즉 환경에 어플리케이션이 영향을 받고 있다는 의미.



한번에 여러 개의 docker 들을 관리하는 툴 같다.

Docker Compose 는 간단하게 여러 Docker application 들을 어떻게 실행할지 정의하고 실행할 수 있는 툴입니다

이렇게 local 환경 관리에 Docker Compose 를 이용했을 때 어떤 장점들이 있을까요?

띄우고 내리는 등의 행위가 편하다
Docker 환경이 파일로 관리된다
협업 하는 모두가 명령어 하나로 쉽게 같은 환경을 사용할 수 있게된다

도커는 ‘이미지를 만들고 컨테이너에 띄우는 도구’이고 쿠버네티스는 ‘도커를 관리하는 툴’이다.

도커라는 것은 컨테이너 기반으로 서비스를 운영할 수 있도록 하는 것.
도커의 장점?

쿠버네티스가 가지는 역할


## 9. nosql vs 관계형 db

읽기 처리를 자주하지만 데이터를 자주 변경하지 않는경우 nosql이 더 낫다..?

RDB는 스키마가 엄격하다. 스키마에 맞지않는 데이터는 추가할 수 없다.
RDB의 장점은 명확한 구조를 가지기 때문에 즉 엄격한 스키마를 따르기 때문에 테이블에서 데이터의 중복이 발생하지 않으며 (사실 발생하지 않는 구조로 정규화 시켜야 한다. 발생하지 않음을 강제하진 않는다. 단지 그걸 추구할 뿐)
데이터의 정합성을 유지하는 것에 포커스를 가진다. 다른 테이블에서 부정확한 데이터를 다룰 위험이 없다.

No-sql

 SQL 세상에서는 정해진 스키마를 따르지 않는다면 데이터를 추가 할 수 없지만, NoSQL에서는 다른 구조의 데이터를 같은 컬렉션(= SQL에서의 테이블)에 추가할 수 있습니다. 이게 핵심적인 차이인듯